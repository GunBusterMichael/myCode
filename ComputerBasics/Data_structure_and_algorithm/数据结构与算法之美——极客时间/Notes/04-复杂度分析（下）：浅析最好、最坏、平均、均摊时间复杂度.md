# 复杂度分析

## 1. 最好情况时间复杂度（best case time complexity）

### 1.1 定义

> 在==最理想==的情况下，执行这段代码的时间复杂度。

### 1.2 代码

```js
function find(array, n, x) {
    var pos = -1
    for (var i = 1; i < n; i++) {
        if (array[i] == x) {
            pos = i
            break
        }
    }
    return pos
    }
}
```

如果要查找的==变量 x 在==数组的==第一位==，则 `find()` 的时间复杂度为 $O(1)$；

==$O(1)$== 为 `find()` 的==最好==情况时间==复杂度==。

## 2. 最坏情况时间复杂度（worst case time complexity）

### 2.1 定义

> 在==最糟糕==的情况下，执行这段代码的时间复杂度。

### 2.2 代码

```js
function find(array, n, x) {
    var pos = -1
    for (var i = 1; i < n; i++) {
        if (array[i] == x) {
            pos = i
            break
        }
    }
    return pos
    }
}
```

如果要查找的==变量 x 在==数组的==最后一位==或==不在==数组中，则 `find()` 的时间复杂度为 $O(n)$；

==$O(n)$== 为 `find()` 的==最坏==情况时间==复杂度==。

## 3. 平均情况时间复杂度（average case time complexity）

### 3.2 定义

> 代码时间复杂度的==加权平均==值。

### 3.1 代码

```js
function find(array, n, x) {
    var pos = -1
    for (var i = 1; i < n; i++) {
        if (array[i] == x) {
            pos = i
            break
        }
    }
    return pos
    }
}
```

1. 假设变量 x 在数组中与不在数组中的概率均为 $\frac{1}{2}$；

2. 变量 x 在索引值 0 ~ n-1 这 n 个位置的概率均为 $\frac{1}{2n}$;

3. 将每种情况下，需要遍历的元素个数累加，再除以 $n+1$，可得需要遍历的元素个数的加权平均值：
   $$
   1\times\frac{1}{2n}+2\times\frac{1}{2n}+3\times\frac{1}{2n}+...+n\times\frac{1}{2n}+n\times\frac{1}{2}=\frac{3n+1}{4}
   $$
   用大 O 法表示，去掉系数和常量，这段代码的平均情况时间复杂度为 $O(n)$。

## 4. 均摊时间复杂度（amortized time complexity）

### 4.1 用处和计算方法

> 对一个数据结构进行==一组连续操作==中，==大部分情况==下时间==复杂度==都很==低==，只有==个别==情况下时间==复杂度==比较==高==，而且这些==操作==之间==存在==前后==连贯==的==时序关系==。
>
> 这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较==高==时间==复杂度==那次操作的耗时，==平摊==到其他==低==时间==复杂度==的操作上。

### 4.2 代码

```js
var array = new Array[n]
var count = 0

function insert(val) {
    if (count == array.length) {
        var sum = 0;
        for (var i = 0; i < array.length; ++i) {
            sum = sum + array[i];
        }
        array[0] = sum;
        count = 1;
    }

    array[count] = val;
    count++;
}
```

#### 4.2.1 摊还分析法

 对于该代码，每一次 $O(n)$ 的插入操作，都会跟着 $n-1$ 次 $O(1)$ 的插入操作；

 将==耗时多==的==操作分摊到== $n-1$ 次==耗时少==的==操作==上，均摊时间复杂的就是 $O(1)$。

### 4.3 均摊时间复杂度与最好情况时间复杂度的关系

在能够应用均摊时间复杂度分析的场合，一般==均摊时间复杂度==就==等于最好情况时间复杂度==。

## 5. 四种时间复杂度的使用场景

很多时候，我们==使用一个==复杂度就可以满足需求了。只有==同一块代码==在==不同的情况==下，时间复杂度有==量级的差距==，我们才会==使用==这==三种复杂度表示法==（最好、最坏、平均）来==区分==。

