# 数据结构与算法

## 1. 复杂度分析

### 1.1 定义

> 一种对代码执行效率的考量标准。

### 1.2 事后统计法

#### 1.2.1 定义

> 运行代码。通过统计、监控，就能得到算法执行的时间和占用的内存大小。

#### 1.2.2 局限性

- 测试结果非常依赖测试环境；
- 测试结果受数据规模的影响很大；

### 1.3 大 O 复杂度表示法

#### 1.3.1 渐进时间复杂度 / 时间复杂度（Asymptotic Time Complexity）

##### 1.3.1.1 定义

> 表示代码执行==时间==随==数据==规模==增长==的==变化趋势==。
>
> ==越高阶复杂度的算法，执行效率越低。==

##### 1.3.1.2 公式

$$
T(n)=O(f(n))
$$

- $T(n)$：代码执行总时间；
- $f(n)$：每行代码执行次数之和；
  - 忽略低阶、常量和系数；
  - 保留最大量级。
- $O$：代表 代码执行总时间$T(n)$ 与 代码执行次数$f(n)$ 成正比。

##### 1.3.1.3 时间复杂度分析

###### 1.3.1.3.1 只关注循环***执行次数最多***的一段代码

```js
function cal(n) {
    var sum = 0
    for (var i = 1; i <= 0; i++) {
        sum = sum + 1
    }
    return sum
}
```

第三行和第四行被执行了 n 次，

其余行的执行次数为常量级，

所以 `cal()` 总的时间复杂度为 $O(n)$。

###### 1.3.1.3.2 比较法则法则：总复杂度等于量级最大的那段代码的复杂度

如果==不同==代码==片段==的==复杂度==可被==比较==，则整段代码适用于==比较法则==：
$$
T(n)=O\{max[f(n),G(n)]\}
$$

```javascript
function cal(n) {
    var sum_1 = 0
    for (p = 1; p < 100; p++) {
        sum_1 = sum_1 + p
    }

    var sum_2 = 0
    for (q = 1; q < n; q++) {
        sum_2 = sum_2 + q
    }

    var sum_3 = 0
    for (i = 1; i <= n; i++) {
        for (j = 1; j <= n; j++) {
            sum_3 = sum_3 + i * j
        }
    }

    return sum_1 + sum_2 + sum_3
}
```

第一段代码的复杂度为 100，忽略；

第二段代码的复杂度为 $O(n)$；

第三段代码的复杂度为 $O(n^2)$；

$O(n)$ < $O(n^2)$，所以整段代码 `cal(n)` 的时间复杂度为 $O(n^2)$。

###### 1.3.1.3.3 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

对于==嵌套代码==，可以使用==加法法则==：
$$
T(n)=O[f(n)*g(n)]
$$

```js
function cal(n) {
    var ret = 0; 
    for (i = 1; i < n; ++i) {
        ret = ret + f(i);
    }
}

function f(n) {
    var sum = 0;
    for (i = 1; i < n; ++i) {
        sum = sum + i;
    }
    return sum;
}
```

第一段代码的时间复杂度 $T_1(n)$ 为 n，

第二段代码（被嵌入到第一段代码）的时间复杂度 $T_1(n)$ 为 n；

所以整个 `cal()` 的时间复杂度为 $T(n) = T1(n) * T2(n) = O(n*n) = O(n^2)$

###### 1.3.1.3.4 加法法则：代码的复杂度由两个数据的规模来决定

<a href="#p13153">1.3.1.5.3 $O(m+n)$、$O(m*n)$</a>

##### 1.3.1.4 复杂度量级

###### 1.3.1.4.1 多项式量级

- 常量阶：$O(1)$
- 对数阶：$O(logn)$

- 线性阶：$O(n)$

- 线性对数阶：$O(nlogn)$

- 平方阶：$O(n^2)$
- 立方阶：$O(n^3)$

- ……
- k 次方阶：$O(n^k)$

###### 1.3.1.4.2 非多项式量级

- 指数阶：$O(2^n)$

- 阶乘阶：$O(n!)$

> 时间复杂度为==非多项式量级==的==算法问题==叫作 ==NP==（Non-Deterministic Polynomial，非确定多项式）问题。

当==数据==规模 n 越来越==大==时，==非多项式==量级算法的==执行时间==会==急剧增加==，求解问题的执行时间会无限增长。所以，非多项式时间复杂度的算法其实是==非常低效==的算法。

###### 1.3.1.4.3 常见的复杂度量级

- $O(1)$
- $O(logn)$
- $O(n)$
- $O(nlogn)$
- $O(n^2)$

![常见的复杂度量级](https://static001.geekbang.org/resource/image/49/04/497a3f120b7debee07dc0d03984faf04.jpg)

##### 1.3.1.5 常见的多项式时间复杂度

###### 1.3.1.5.1 $O(1)$

1. 定义

   > ==常量级==时间复杂度，代码的==执行时间不随 n== 的增大而增长。
   
   ​		一般情况下，只要算法中==不存在循环==语句、==递归==语句，即使有成千上万行的代码，其==时间复杂度==也是==$Ο(1)$==。

2. 代码示例

   ```js
   var i = 8
   var j = 6
   var sum = i + j
   ```

###### 1.3.1.5.2 $O(logn)$、$O(nlogn)$

1. 定义

   > 对数阶时间复杂度。

2. $O(logn)$ 代码示例

   ```
   var i=1
   while (i <= n) {
   	i = i * 2
   }
   ```

   第三行代码的执行次数最多，

   第三行代码可被看作是 $2^x$，当 $2^x>n$时，循环结束。

   所以第三行的执行次数是 $2^x=n$ 时的 $x$ 值，==$x=log_2n$==。

   由于对数之间可以相互转化，所以==省略对数的底==，该代码的时间复杂度为 ==$O(logn)$==。

3. $O(nlogn)$ 代码示例

   ```js
   var i = 1
   for (var j = 1; j <= n; j++) {
       while (i <= n) {
   		i = i * 2
   	}
   }
   ```

   第二行代码执行 n 遍，第四行代码执行 $log_2n$ 遍；

   相当于==将时间复杂度为 $O(logn)$ 的代码执行了 n 遍==，

   整段代码的时间复杂度为 ==$O(nlogn)$==。

###### <span id="p13153">1.3.1.5.3 $O(m+n)$、$O(m*n)$</span>

1. 特点

   代码的复杂度==由两个数据==的规模来==决定==。

2. 代码示例

   ```js
   function cal(m, n) {
       var sum_1 = 0
       for (var i = 1; i < m; i++) {
           sum_1 = sum_1 + i
       }
   
       var sum_2 = 0
       for (var j = 1; j < n; j++) {
           sum_2 = sum_2 + j
       }
   
       return sum_1 + sum_2
   }
   ```

​		 第三四行代码的执行次数为 m，第第八九行代码的执行次数为 n；

​		 我们无法事先评估 m、n 谁大谁小，所以 `cal(m, n)` 函数的时间复杂度为 $O(m+n)$。

#### 1.3.2 渐进空间复杂度 / 空间复杂度（Asymptotic Space Complexity）

##### 1.3.2.1 定义

> 算法的==存储空间==与==数据规模==之间的==增长关系==。

##### 1.3.2.2 代码示例

```js
function print(n) {
    var a = new Array[n]
    for (var i = 0; i < n; i++) {
        a[i] = i * i
    }

    for (var j = n - 1; j >= 0; j--) {
        console.log(a[i]);
    }
}
```

第二行申请了一个==大小==为 ==n== 的==数组==，占用了大小为 n 的空间；

第三行和第七行分别申请了大小为常量阶的变量，占用了大小为常量阶空间；

所以整段代码的==空间复杂度==为 ==$O(n)$==。

##### 1.3.2.3 常见的空间复杂度

常见的空间复杂度是 ==$O(1$)==、==$O(n)$==、==$O(n^2)$==。
